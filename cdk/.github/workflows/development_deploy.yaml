name: Development Deployment
on:
  workflow_dispatch:
  # We run the deployment on any push to main
  push:
    branches:
      - main
jobs:
  generate-Semver:
    runs-on: ubuntu-latest
    outputs:
      GitVersion_BranchName: ${{ steps.version_step.outputs.GitVersion_BranchName }}
      GitVersion_FullSemVer: ${{ steps.version_step.outputs.GitVersion_FullSemVer }}
    permissions:
      contents: read    # This is required for actions/checkout
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v1.1.1
        with:
          versionSpec: '5.x'
      - name: Determine Version
        id: version_step
        uses: gittools/actions/gitversion/execute@v1.1.1
        with:
          useConfigFile: true
  identify-services:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.load_service_names.outputs['app_services'] }}
    permissions:
      contents: read    # This is required for actions/checkout
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - name: Load GithubActions and frontend Config
        id: load_service_names
        uses: ./.github/actions/load-yaml-action
        with:
          file_path: config/development.yaml
          keys_to_load: "app_services"
          max_depth: 0
          key_modification: "lower"
          value_modification: sanitize
  build-push-services:
    needs: [identify-services, generate-Semver]
    env:
      fullSemVer: ${{ needs.generate-Semver.outputs.GitVersion_FullSemVer }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write   # This is required for requesting the JWT
      contents: read    # This is required for actions/checkout
    strategy:
      matrix:
        service_name: ${{ fromJson(needs.identify-services.outputs.services) }}
    steps:
      # Checkout the code first
      - name: Checkout Code
        uses: actions/checkout@v2
      # We read the yaml configuration file for development
      - name: Load Github Actions AWS Credentials
        id: load_github_actions_config
        uses: ./.github/actions/load-yaml-action
        with:
          file_path: config/development.yaml
          keys_to_load: "github_actions"
      - name: Load Config
        id: load_config
        uses: ./.github/actions/load-yaml-action
        with:
          file_path: config/development.yaml
          keys_to_load: "app_name, app_services"
          key_modification: "lower"
          value_modification: sanitize
      # Configure AWS credentials for CDK diff and deploy
      - name: Load AWS Account
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ steps.load_github_actions_config.outputs['github_actions.aws_deploy_role'] }}
          aws-region: ${{ steps.load_github_actions_config.outputs['github_actions.aws_region'] }}
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Create the repository
        shell: bash
        run: |
          aws ecr describe-repositories --repository-names ${{ steps.load_config.outputs['app_name'] }}/${{ matrix.service_name }} || aws ecr create-repository --repository-name ${{ steps.load_config.outputs['app_name'] }}/${{ matrix.service_name }}
      - name: Generate Image Tags
        id: docker-metadata
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ steps.load_config.outputs['app_name'] }}/${{ matrix.service_name }}
          tags: |
            type=sha,format=long
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ env.fullSemVer }}
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./${{ steps.load_config.outputs[format('app_services.{0}.directory', matrix.service_name)] }}
          push: true
          tags: ${{ steps.docker-metadata.outputs.tags }}
          labels: ${{ steps.docker-metadata.outputs.labels }}
          # We use the service name as the target (because some build contexts may use the same dockerfile but different targets)
          target: ${{ matrix.service_name }}
  # We built the docker images for development
  # Whenever we have development environment changes we want to deploy cdk
  # We reference the SHA of the github image so that cdk deploy works properly and automatically creates a new task definition
  deploy-cdk:
    runs-on: ubuntu-latest
    needs: [generate-Semver, build-push-services]
    env:
      fullSemVer: ${{ needs.generate-Semver.outputs.GitVersion_FullSemVer }}
    permissions:
      id-token: write   # This is required for requesting the JWT
      contents: read    # This is required for actions/checkout
    steps:
      # Checkout the code first
      - name: Checkout Code
        uses: actions/checkout@v2
      # We read the yaml configuration file for development
      - name: Load Config
        id: load_config
        uses: ./.github/actions/load-yaml-action
        with:
          file_path: config/development.yaml
          keys_to_load: "github_actions, aws, app_name, env"
      # Configure AWS credentials for CDK diff and deploy
      - name: Load AWS Account
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ steps.load_config.outputs['github_actions.aws_deploy_role'] }}
          aws-region: ${{ steps.load_config.outputs['github_actions.aws_region'] }}
      ## We install CDK
      - name: Install AWS CDK
        run: |
          pip install -r ${PWD}/cdk/requirements.txt
          npm install -g aws-cdk
      - name : Verify If stack exists
        id: stack-exists-check
        env:
          REGION: ${{ steps.load_config.outputs['aws.region'] }}
          STACK_NAME: ${{ steps.load_config.outputs['app_name'] }}-${{ steps.load_config.outputs['env']}}
        run: |
          if ! aws cloudformation describe-stacks --region ${{ env.REGION }} --stack-name ${{ env.STACK_NAME }} ; then
            echo -e "Stack does not exist - no need to run drift detection"
            echo "stack_exists=0" >> "$GITHUB_OUTPUT"
          else
            echo -e "Stack exists - proceed with drift detection"
            echo "stack_exists=1" >> "$GITHUB_OUTPUT"
          fi
      - name: Detect Drift on Development
        id: drift_detect
        if: ${{ steps.stack-exists-check.outputs.stack_exists == 1 }}
        uses: TRI-ML/cdk-drift-check@v0.0.4
        env:
          APP_NAME: ${{ steps.load_config.outputs['app_name'] }}
          ENVIRONMENT: ${{ steps.load_config.outputs['env'] }}
        with:
          stack_name: "${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
      - name: Show Drift
        shell: bash
        if: steps.drift_detect.outputs.result == 'DRIFTED'
        run: |
            echo '${{ steps.drift_detect.outputs.details }}' | python3 -mjson.tool
      - name: Run CDK Deploy
        run: |
          cd ./cdk
          cdk deploy --require-approval never -c image_tag=${{ env.fullSemVer }} -c deploy_env=${{ steps.load_config.outputs['env'] }}