name: Dev Deploy

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  # -----------------------------------------------------------------------
  # Generate a semantic version number used to tag images and the CDK deploy
  # -----------------------------------------------------------------------
  generate-semver:
    runs-on: ubuntu-latest
    outputs:
      fullSemVer: ${{ steps.version_step.outputs.GitVersion_FullSemVer }}
    permissions:
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v1.1.1
        with:
          versionSpec: "5.x"

      - name: Determine Version
        id: version_step
        uses: gittools/actions/gitversion/execute@v1.1.1
        with:
          useConfigFile: true
          configFilePath: cdk/GitVersion.yml

  # -----------------------------------------------------------------------
  # Download the pre-built WebArena images and push them to ECR.
  # Images are processed sequentially (not as a matrix) because they are
  # large; handling them one at a time keeps disk usage manageable.
  # -----------------------------------------------------------------------
  push-images:
    needs: [generate-semver]
    runs-on: ubuntu-latest
    env:
      fullSemVer: ${{ needs.generate-semver.outputs.fullSemVer }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Load Config
        id: load_config
        uses: ./cdk/.github/actions/load-yaml-action
        with:
          file_path: cdk/config/dev.yaml
          keys_to_load: "github_actions, app_name"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ steps.load_config.outputs['github_actions.aws_deploy_role'] }}
          aws-region: ${{ steps.load_config.outputs['github_actions.aws_region'] }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # --- Shopping (storefront) ---
      - name: Download shopping image
        run: |
          curl -fL -o shopping.tar \
            http://metis.lti.cs.cmu.edu/webarena-images/shopping_final_0712.tar

      - name: Push shopping to ECR
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          APP_NAME: ${{ steps.load_config.outputs['app_name'] }}
        run: |
          LOAD_OUTPUT=$(docker load -i shopping.tar)
          echo "$LOAD_OUTPUT"
          SOURCE=$(echo "$LOAD_OUTPUT" | tail -1 | awk '{print $NF}')
          ECR_REPO="${REGISTRY}/${APP_NAME}/shopping"

          aws ecr describe-repositories --repository-names "${APP_NAME}/shopping" \
            || aws ecr create-repository --repository-name "${APP_NAME}/shopping"

          docker tag "$SOURCE" "${ECR_REPO}:${fullSemVer}"
          docker tag "$SOURCE" "${ECR_REPO}:latest"
          docker push "${ECR_REPO}:${fullSemVer}"
          docker push "${ECR_REPO}:latest"

          # Free disk space before processing the next image
          rm shopping.tar
          docker rmi "$SOURCE" || true

      # --- Shopping Admin (merchant CMS) ---
      - name: Download shopping-admin image
        run: |
          curl -fL -o shopping-admin.tar \
            http://metis.lti.cs.cmu.edu/webarena-images/shopping_admin_final_0719.tar

      - name: Push shopping-admin to ECR
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          APP_NAME: ${{ steps.load_config.outputs['app_name'] }}
        run: |
          LOAD_OUTPUT=$(docker load -i shopping-admin.tar)
          echo "$LOAD_OUTPUT"
          SOURCE=$(echo "$LOAD_OUTPUT" | tail -1 | awk '{print $NF}')
          ECR_REPO="${REGISTRY}/${APP_NAME}/shopping-admin"

          aws ecr describe-repositories --repository-names "${APP_NAME}/shopping-admin" \
            || aws ecr create-repository --repository-name "${APP_NAME}/shopping-admin"

          docker tag "$SOURCE" "${ECR_REPO}:${fullSemVer}"
          docker tag "$SOURCE" "${ECR_REPO}:latest"
          docker push "${ECR_REPO}:${fullSemVer}"
          docker push "${ECR_REPO}:latest"

          rm shopping-admin.tar
          docker rmi "$SOURCE" || true

  # -----------------------------------------------------------------------
  # Deploy infrastructure with CDK using the semver image tag so that ECS
  # always picks up the latest pushed image.
  # -----------------------------------------------------------------------
  deploy-cdk:
    runs-on: ubuntu-latest
    needs: [generate-semver, push-images]
    env:
      fullSemVer: ${{ needs.generate-semver.outputs.fullSemVer }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Load Config
        id: load_config
        uses: ./cdk/.github/actions/load-yaml-action
        with:
          file_path: cdk/config/dev.yaml
          keys_to_load: "github_actions, aws, app_name, env"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ steps.load_config.outputs['github_actions.aws_deploy_role'] }}
          aws-region: ${{ steps.load_config.outputs['github_actions.aws_region'] }}

      - name: Install AWS CDK
        run: |
          pip install -r cdk/cdk/requirements.txt
          npm install -g aws-cdk

      - name: Verify if stack exists
        id: stack-exists-check
        run: |
          if ! aws cloudformation describe-stacks \
            --region ${{ steps.load_config.outputs['aws.region'] }} \
            --stack-name ${{ steps.load_config.outputs['app_name'] }}-${{ steps.load_config.outputs['env'] }}; then
            echo "stack_exists=0" >> "$GITHUB_OUTPUT"
          else
            echo "stack_exists=1" >> "$GITHUB_OUTPUT"
          fi

      - name: Detect Drift
        id: drift_detect
        if: ${{ steps.stack-exists-check.outputs.stack_exists == 1 }}
        uses: TRI-ML/cdk-drift-check@v0.0.4
        env:
          APP_NAME: ${{ steps.load_config.outputs['app_name'] }}
          ENVIRONMENT: ${{ steps.load_config.outputs['env'] }}
        with:
          stack_name: "${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"

      - name: Show Drift
        if: steps.drift_detect.outputs.result == 'DRIFTED'
        run: |
          echo '${{ steps.drift_detect.outputs.details }}' | python3 -mjson.tool

      - name: Run CDK Deploy
        run: |
          cd cdk/cdk
          cdk deploy --require-approval never \
            -c image_tag=${{ env.fullSemVer }} \
            -c deploy_env=${{ steps.load_config.outputs['env'] }}
